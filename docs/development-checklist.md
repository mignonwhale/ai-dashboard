# AI 어시스턴트 대시보드 - 개발 체크리스트

## 1단계: 기본 인프라 구축 (1-2주)

### Supabase 설정

- [x] Supabase 프로젝트 생성
- [x] PostgreSQL 데이터베이스 설정
- [x] 데이터베이스 테이블 생성:
  - [x] `users` 테이블
  - [x] `ai_chat` 테이블
  - [x] `ai_text_gen` 테이블
  - [x] `files` 테이블
  - [x] `todos` 테이블
  - [x] `csv_analysis` 테이블
- [x] Supabase 인증 설정
- [x] 파일 스토리지 버킷 설정 (`files` 버킷 생성 완료)
- [x] RLS(Row Level Security) 정책 구성 (sql/supabase-rls-policies.sql 제공)

### Next.js 프로젝트 초기화

- [x] Next.js 15 프로젝트 생성 (App Router 사용)
- [x] TypeScript 설치 및 설정
- [x] DaisyUI + Tailwind CSS 설치 및 설정
- [x] Yarn 패키지 매니저 설정
- [x] 기본 라우팅 구조 설정:
  - [x] 루트 레이아웃 (`app/layout.tsx`)
  - [x] 홈페이지 (`app/page.tsx`)
  - [x] 인증 페이지 (`app/auth/page.tsx`)
  - [x] 대시보드 페이지 (`app/dashboard/page.tsx`)

## 2단계: 인증 시스템 (1주)

### 사용자 인증 구현

- [x] Supabase 클라이언트 설정 (`lib/supabaseClient.ts`)
- [x] 로그인/회원가입 폼이 있는 인증 페이지 구현
- [x] 세션 관리 추가 (AuthContext 구현)
- [x] **비밀번호 재설정 기능 구현** (`/auth/reset-password`)
- [x] **이메일/비밀번호 검증 시스템** (실시간 검증)
- [x] 로그아웃 기능 구현 (대시보드 헤더)
- [x] 보호된 라우트 구현 (useEffect 기반 리다이렉트)
- [x] 인증 플로우 종단간 테스트 완료

## 3단계: 대시보드 기본 구조 (1-2주)

### 대시보드 레이아웃

- [x] 반응형 대시보드 레이아웃 생성
- [x] 내비게이션 컴포넌트 구현
- [x] 대시보드 레이아웃 컴포넌트 (`DashboardLayout.tsx`) 생성
- [x] 모바일 반응형 디자인 추가
- [x] 기본 컴포넌트 구조 구현:
  - [x] 사용자 정보가 포함된 헤더
  - [x] **사이드바 내비게이션** (usePathname 기반 활성 상태)
  - [x] 메인 콘텐츠 영역
  - [x] **동적 페이지 타이틀** 시스템

### 기본 컴포넌트

- [x] **로딩 상태 구현** (스피너, 스켈레톤 포함)
- [x] **에러 처리 시스템** (try-catch, 사용자 친화적 메시지)
- [x] **공통 UI 요소** (DaisyUI 기반)
- [x] **일관된 컴포넌트 테마** (Tailwind + DaisyUI)

## 4단계: 핵심 기능 구현 (4-6주)

### 1. AI 챗봇 기능

- [x] **Gemini API 연동 완료** (`lib/gemini.ts`) - 구글 Gemini 1.5 Flash 모델
- [x] API 라우트 생성 (`api/chat/route.ts`)
- [x] AI 챗 컴포넌트 구축 (`AIChat.tsx`)
- [x] **완전한 챗 인터페이스 UI**:
  - [x] 메시지 입력 필드
  - [x] 채팅 기록 표시
  - [x] **로딩 상태 표시** (타이핑 효과)
  - [x] 메시지 타임스탬프
  - [x] **대화 지우기 기능** (DB 연동)
- [x] **데이터베이스 대화 저장** (ai_chat 테이블)
- [x] **실시간 채팅 기록** 관리
- [x] **메시지 역할 구분** (사용자/어시스턴트)
- [x] **전체 화면 레이아웃** 최적화
- [x] **챗 기능 완전 테스트** 완료

### 2. AI 텍스트 생성기

- [x] 텍스트 생성 API 라우트 생성 (`api/text-gen/route.ts`)
- [x] **TextGenerator 컴포넌트 완전 구축**
- [x] **완전한 UI 구현**:
  - [x] 프롬프트 입력 (다중 라인 지원)
  - [x] **콘텐츠 유형 선택** (블로그/마케팅/일반)
  - [x] **생성된 텍스트 표시** (마크다운 지원)
  - [x] **클립보드 복사 기능** 완료
  - [x] **로딩 상태 및 오류 처리**
- [x] **생성 기록 시스템** (ai_text_gen 테이블)
- [x] **데이터베이스 저장** 완료
- [x] **텍스트 생성 전체 테스트** 완료

### 3. 파일 분석 기능

- [x] **파일 업로드 시스템 완전 구축**
- [x] **파일 파서 유틸리티** (`lib/fileParser.ts`) - PDF, TXT, DOC, DOCX 지원
- [x] **파일 분석 API 완료** (`api/file-analyze/route.ts`)
- [x] **FileAnalyzer 컴포넌트 완전 구현**
- [x] **고급 파일 업로드 UI**:
  - [x] **드래그 앤 드롭 영역** (시각적 피드백 포함)
  - [x] **파일 유형 및 크기 검증** (10MB 제한)
  - [x] **업로드 진행률 표시**
  - [x] **업로드된 파일 목록** 관리
- [x] **다중 파일 형식 파싱** (PDF, TXT, DOC, DOCX)
- [x] **Gemini AI 분석 연동** 완료
- [x] **구조화된 분석 결과** (요약, 핵심 포인트, 인사이트)
- [x] **확장된 결과 표시 영역** (max-h-48rem)
- [x] **파일 메타데이터 DB 저장** (files 테이블)
- [x] **Supabase Storage 연동** (업로드 실패 시에도 분석 진행)
- [x] **파일 분석 전체 테스트** 완료

### 4. 할 일 목록 + AI 추천

- [x] **완전한 할 일 API 시스템**:
  - [x] **CRUD API 라우트** (`/api/todos`)
  - [x] **AI 추천 API** 연동
  - [x] **RLS 정책 적용** (사용자별 데이터 격리)
- [x] **TodoList 컴포넌트 완전 구축**
- [x] **고급 할 일 관리 UI**:
  - [x] **할 일 입력 폼** (유효성 검사 포함)
  - [x] **할 일 목록 표시** (완료/미완료 구분)
  - [x] **완료 체크박스** (즉시 DB 업데이트)
  - [x] **삭제 기능** (확인 다이얼로그 포함)
  - [x] **AI 추천 기능** (기존 할일 기반)
- [x] **Gemini AI 추천 시스템** 완료
- [x] **사용자 컨텍스트 기반 추천** 구현
- [x] **할 일 CRUD 완전 테스트** 완료

### 5. 데이터 시각화 (CSV 분석)

- [x] **CSV 분석 API 완전 구축** (`api/csv-analyze/route.ts`)
- [x] **Chart.js 기반 차트 시스템** (react-chartjs-2)
- [x] **DataVisualizer 컴포넌트 완전 구현**
- [x] **통합된 Chart 렌더링** 시스템
- [x] **고급 CSV 처리**:
  - [x] **CSV 업로드 및 파싱** 완료
  - [x] **실제 데이터 기반 차트** 생성
  - [x] **데이터 검증 및 정제**
- [x] **Gemini AI 데이터 분석** 연동
- [x] **다양한 차트 유형** 자동 생성:
  - [x] **막대 차트** (Bar Chart)
  - [x] **선 그래프** (Line Chart)
  - [x] **원형 차트** (Pie Chart)
  - [x] **동적 차트 선택** 시스템
- [x] **분석 결과 DB 저장** (csv_analysis 테이블)
- [x] **차트 상호작용** 기능
- [x] **CSV 분석 전체 워크플로우** 테스트 완료

## 5단계: API 연동 및 외부 서비스

### 외부 API 설정

- [x] Gemini API 자격 증명 설정 (Google AI Studio 무료 티어 사용)
- [x] 모든 AI 기능을 Gemini API로 통합 완료
- [x] API 오류 처리 구현
- [x] 요청 제한 고려사항 추가 (Gemini API 제한)
- [x] Gemini API 연결 테스트 완료

### 타입 정의

- [x] TypeScript 타입 생성 (supabaseClient.ts에 통합):
  - [x] 채팅 관련 타입 (AIChat)
  - [x] 할 일 관련 타입 (Todo)
  - [x] CSV 분석 타입 (CSVAnalysis)
  - [x] 파일 분석 타입 (FileAnalysis)
  - [x] 사용자 타입 (User)
  - [x] AI 텍스트 생성 타입 (AITextGen)

## 6단계: 보안 및 성능

### 보안 구현

- [x] API 키 환경변수 관리 구현
- [x] 파일 업로드 보안 조치 추가:
  - [x] 파일 유형 제한
  - [x] 파일 크기 제한
  - [x] 악성코드 스캔 고려사항
- [x] CORS 정책 설정
- [x] 요청 제한 구현
- [x] 입력 검증 및 정제 추가
- [x] CSP 헤더 설정

### 성능 최적화

- [x] 코드 분할 구현
- [x] 이미지 최적화 추가
- [x] 캐싱 전략 설정
- [x] 번들 크기 최적화
- [x] 로딩 상태 및 스켈레톤 스크린 추가
- [x] 지연 로딩 구현

## 7단계: 테스트 및 품질 보증

### 테스트 설정

- [x] 단위 테스트용 Vitest 설정 (Jest에서 마이그레이션)
- [x] React Testing Library 설정
- [x] Vitest UI 모드 설정
- [x] E2E 테스트용 Cypress 설치
- [x] 실제 환경변수로 API 통합 테스트 구현
- [ ] API 모킹용 MSW 설정 (선택사항 - 팀 프로젝트 확장 시)

### 테스트 구현

- [x] 컴포넌트 단위 테스트 작성 (validation 유틸리티)
- [x] 사용자 플로우 E2E 테스트 구현:
  - [x] 인증 플로우 (기본 UI 테스트)
  - [x] 채팅 기능 (메시지 송수신 테스트)
  - [x] 파일 업로드 및 분석 (PDF 파일 형식 검증 포함)
  - [x] 할 일 관리 (AI 추천, CRUD 작업, 지속성 테스트)
  - [x] 텍스트 생성기 (AI 생성, validation, 복사 기능)
  - [x] CSV 분석 (파일 업로드, AI 분석, 차트 시각화)
- [x] 오류 시나리오 테스트 추가 (빈 입력, 잘못된 형식)
- [x] 테스트 안정성 개선 (data-testid, DOM 탐색, 상태 비교)
- [x] 반응형 디자인 확인 (수동 테스트 - Tailwind CSS 활용)

## 8단계: 배포 및 DevOps

### 배포 설정

- [x] **Vercel 배포 설정** (`vercel.json` 파일 생성 완료)
- [x] **프로덕션 환경변수 설정** (`.env.production.example` 파일 생성 완료)
- [ ] 도메인 및 SSL 설정 (선택사항 - 포트폴리오용)
- [ ] 스테이징 환경 설정 (선택사항)

### CI/CD 파이프라인

- [x] **GitHub Actions CI 설정** (`.github/workflows/ci.yml` 파일 생성 완료)
- [x] **자동화된 테스트 설정** (린트, 타입체크, 단위테스트, E2E 테스트)
- [x] **포트폴리오용 CI 파이프라인** (배포는 Vercel 자체 기능 사용)
- [ ] 헬스 체크 추가 (선택사항)
- [ ] 모니터링 및 알림 설정 (선택사항)

### 환경 변수

- [x] **개발 환경변수 설정 완료**:
  - [x] `NEXT_PUBLIC_SUPABASE_URL`
  - [x] `NEXT_PUBLIC_SUPABASE_ANON_KEY`
  - [x] `GEMINI_API_KEY`
- [x] **GitHub Secrets 설정 필요** (3개 동일 변수):
  - [x] GitHub 저장소 → Settings → Secrets에 위 3개 변수 추가
- [x] **Vercel 환경변수 설정 필요**:
  - [x] Vercel 대시보드에서 위 3개 변수 추가

### 🚀 배포 프로세스

1. **GitHub 저장소 → Vercel 연결**
2. **환경변수 설정** (GitHub Secrets + Vercel)
3. **자동 배포** (`git push origin main` 시 자동 실행)

## 9단계: 모니터링 및 분석

### 모니터링 설정

- [ ] Vercel Analytics 설정
- [ ] Core Web Vitals 추적 설정
- [ ] API 응답 시간 모니터링 구현
- [ ] 오류 로깅 및 추적 추가
- [ ] 사용자 분석 설정

### 성능 모니터링

- [ ] 데이터베이스 쿼리 성능 모니터링
- [ ] API 사용량 및 비용 추적
- [ ] 중요 이슈에 대한 알림 설정
- [ ] 사용자 활동 추적 구현

## 10단계: 문서화 및 유지보수

### 문서화

- [x] **설정 지침이 포함된 README 업데이트** (완료)
- [x] **배포 가이드 작성** (`docs/deployment-guide.md` 생성 완료)
- [ ] API 문서 생성 (선택사항)
- [ ] 컴포넌트 사용법 문서화 (선택사항)
- [x] **문제 해결 가이드 생성** (이미 완료)

### 코드 품질

- [x] **ESLint 설정** (완료)
- [x] **코드 포매팅용 Prettier 설정** (완료)
- [x] **pre-commit hook 추가** (Husky + lint-staged 설정 완료)
- [ ] 코드 리뷰 프로세스 구현 (선택사항 - 개인 프로젝트)
- [ ] 의존성 업데이트 일정 설정 (선택사항)

## 향후 개선사항 (MVP 이후)

### 확장 기능

- [ ] 다국어 지원 (i18n)
- [ ] 실시간 알림
- [ ] 모바일 앱 개발
- [ ] 고급 데이터 분석 기능
- [ ] 팀 협업 기능
- [ ] API 버전 관리
- [ ] 고급 사용자 역할 및 권한
- [ ] 서드파티 서비스 통합
- [ ] 사용자 정의 대시보드 위젯
- [ ] 내보내기/가져오기 기능

---

## 진행 상황 추적

**현재 단계:** 8단계 (배포 및 DevOps) - 완료 ✅  
**완료 비율:** 약 90%  
**마지막 업데이트:** 2025-08-18

### 🎉 배포 준비 완료!

프로젝트가 **프로덕션 배포 준비 상태**에 도달했습니다. 이제 Vercel에 배포하여 실제 사용자들이 접근할 수 있습니다.

### 참고사항

- 각 체크박스는 완료된 작업을 나타냅니다
- 우선순위 작업은 **굵게** 표시됩니다
- 각 단계별 예상 소요 시간이 포함되어 있습니다
- 정기적으로 진행 상황을 업데이트해야 합니다

---

## 📚 추후 확장 시 참고사항

### MSW (Mock Service Worker) 도입 고려 시점

현재 프로젝트는 Cypress + Vitest로 충분한 테스트 커버리지를 확보했지만, 다음 상황에서 MSW 도입을 고려할 수 있습니다:

#### 도입이 필요한 경우

- **팀 프로젝트 확장**: 신규 개발자가 환경변수 없이 테스트해야 할 때
- **CI/CD 파이프라인**: 외부 API 의존성 없이 자동화된 테스트 필요
- **복잡한 API 에러 처리**: 다양한 실패 시나리오 테스트가 중요할 때
- **API 요금 절약**: 대량의 테스트로 인한 API 비용 부담

#### MSW 구현 예시

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw'

export const handlers = [
  // Gemini API 모킹
  http.post('/api/chat', () => {
    return HttpResponse.json({
      message: 'Mock AI 응답입니다.',
    })
  }),

  // 에러 시나리오 모킹
  http.post('/api/text-gen', () => {
    return HttpResponse.json({ error: 'API 한도 초과' }, { status: 429 })
  }),
]
```

#### 현재 테스트 전략의 장점

- ✅ 실제 API와의 통합 검증
- ✅ 실제 사용자 환경과 동일한 테스트
- ✅ 설정 복잡도 최소화
- ✅ 빠른 피드백 루프

따라서 현재는 MSW 없이도 충분한 품질 보장이 가능하며, 프로젝트 규모나 팀 요구사항 변화 시 도입을 검토하는 것이 적절합니다.
